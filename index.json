[{"categories":["数据结构","go"],"content":"B+树 // Node represents a node in a binary search tree. type Node struct { // Key is the value stored in the node. Key int // Left and right are the left and right children of the node. Left, Right *Node } // BST is a binary search tree. type BST struct { // Root is the root node of the tree. Root *Node } // Insert inserts a new key into the tree. func (bst *BST) Insert(key int) { node := \u0026Node{Key: key} if bst.Root == nil { bst.Root = node return } current := bst.Root for current != nil { if key \u003c current.Key { if current.Left == nil { current.Left = node return } current = current.Left } else { if current.Right == nil { current.Right = node return } current = current.Right } } } ","date":"2022-12-12","objectID":"https://xie-wenlin.github.io/posts/b+%E6%A0%91/:0:0","tags":["go","数据结构"],"title":"B+树","uri":"https://xie-wenlin.github.io/posts/b+%E6%A0%91/"},{"categories":["数据结构","go"],"content":"学习一下 ","date":"2022-12-12","objectID":"https://xie-wenlin.github.io/posts/b+%E6%A0%91/:0:1","tags":["go","数据结构"],"title":"B+树","uri":"https://xie-wenlin.github.io/posts/b+%E6%A0%91/"},{"categories":["数据结构","go"],"content":"二叉搜索树 // Node represents a node in a binary search tree. type Node struct { // Key is the value stored in the node. Key int // Left and right are the left and right children of the node. Left, Right *Node } // BST is a binary search tree. type BST struct { // Root is the root node of the tree. Root *Node } // Insert inserts a new key into the tree. func (bst *BST) Insert(key int) { node := \u0026Node{Key: key} if bst.Root == nil { bst.Root = node return } current := bst.Root for current != nil { if key \u003c current.Key { if current.Left == nil { current.Left = node return } current = current.Left } else { if current.Right == nil { current.Right = node return } current = current.Right } } } ","date":"2022-12-12","objectID":"https://xie-wenlin.github.io/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:1:0","tags":["go","数据结构"],"title":"二叉搜索树","uri":"https://xie-wenlin.github.io/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["go"],"content":"数据库 ","date":"2022-12-12","objectID":"https://xie-wenlin.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/:0:0","tags":["go","并发"],"title":"数据库","uri":"https://xie-wenlin.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["go"],"content":"go的并发 在 Go 中，您可以使用 goroutine 来编写并发代码。goroutine 是一种轻量级的线程，它允许您在单个进程中执行多个任务。您可以通过在函数名之前添加 go 关键字来创建一个 goroutine。下面是一个简单的例子： package main import \"fmt\" func main() { go fmt.Println(\"Hello, world!\") } 在这个例子中，我们创建了一个 goroutine 来打印 “Hello, world!\"。这个 goroutine 会在 main 函数返回之前执行，因此您可以使用 goroutine 来执行需要长时间运行的任务。 如果你想写一个优美的 Go 并发程序，你需要遵循一些基本的原则。首先，在 Go 中使用通信来共享内存，而不是通过共享内存来通信。这意味着，在 Go 程序中，你应该尽量使用通道（channels）来在 goroutines 之间传递数据。 其次，你应该尽量避免使用全局变量，因为它们会使程序的并发性变得更加困难。相反，你应该通过函数参数和返回值来传递数据。 此外，你应该注意避免竞争条件（race condition），这是指在多个 goroutines 之间发生的不确定的状态更改。这可以通过 Go 语言提供的 sync 包中的互斥锁（mutex）来解决。你还需要掌握 Go 语言中的并发模型。Go 语言提供了一种简单而有效的并发模型，通过 goroutine 和 channel 来实现。使用 goroutine 可以创建并行的任务，通过 channel 可以在多个 goroutine 之间传递消息。 package main import \"fmt\" func main() { // 创建一个通道，用于在 goroutine 之间传递消息。 messages := make(chan string) // 创建 5 个 goroutine。 for i := 0; i \u003c 5; i++ { go func() { // 在通道中发送一条消息。 messages \u003c- \"Hello, World!\" }() } // 从通道中接收并打印 5 条消息。 for i := 0; i \u003c 5; i++ { fmt.Println(\u003c-messages) } } Hello, World! Hello, World! Hello, World! Hello, World! Hello, World! package main import ( \"fmt\" \"sync\" ) // 定义一个函数，用于在并发执行 func printHello(wg *sync.WaitGroup, id int) { // 在函数结束时通知WaitGroup defer wg.Done() // 打印Hello fmt.Println(\"Hello from goroutine\", id) } func main() { // 创建WaitGroup var wg sync.WaitGroup // 设置要执行的并发数量 wg.Add(5) // 循环创建5个goroutine for i := 1; i \u003c= 5; i++ { // 开启一个新的goroutine go printHello(\u0026wg, i) } // 等待所有goroutine结束 wg.Wait() } 在这个例子中，我们创建了一个WaitGroup用于等待所有goroutine结束，并在每个goroutine结束时调用Done方法，告知WaitGroup已经结束。在主goroutine中，我们调用Add方法来设置并发的数量，并调用Wait方法来等待所有goroutine结束。 ","date":"2022-12-10","objectID":"https://xie-wenlin.github.io/posts/go%E7%9A%84%E5%B9%B6%E5%8F%91/:0:0","tags":["go","并发"],"title":"go的并发","uri":"https://xie-wenlin.github.io/posts/go%E7%9A%84%E5%B9%B6%E5%8F%91/"},{"categories":["设计模式","go"],"content":"go懒汉模式 “懒汉模式”（lazy instantiation）是指在第一次使用时才会创建对象的方法。这与饿汉模式（eager instantiation）不同，饿汉模式会在程序启动时就创建对象。 Go 语言中的懒汉模式指的是在需要的时候才创建对象的方式。这种方式的好处是可以节省内存，因为对象只有在真正需要的时候才会被创建。不过，使用懒汉模式时需要注意线程安全问题。Go语言没有直接支持懒汉模式的语法，但是你可以通过编写一个函数来实现这个模式。例如： var instance *Singleton func GetInstance() *Singleton { if instance == nil { instance = \u0026Singleton{} } return instance } 在这个函数中，我们首先检查实例是否为空，如果是，我们创建一个新的实例并将其保存到变量中。如果实例已经存在，我们直接返回它。 需要注意的是，由于Go语言没有类型，所以我们需要使用一个全局变量来保存实例。这可能会导致一些问题，例如多个单例实例之间的冲突，因此在实际开发中应该谨慎使用。 在 go 语言中，可以使用 sync.Once 类型来实现懒汉模式,解决多个单例之间的冲突。例如： import \"sync\" var once sync.Once var instance *MyType func GetInstance() *MyType { once.Do(func() { instance = \u0026MyType{} }) return instance } 在上面的代码中，GetInstance 函数使用 sync.Once 类型来确保 instance 变量只会被创建一次。 不过，在 go 语言中，懒汉模式并不是很常用。因为 go 语言的并发模型和其他语言不太一样，所以在 go 中很少有需要用到懒汉模式的场景。 ","date":"2022-12-10","objectID":"https://xie-wenlin.github.io/posts/%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/:0:0","tags":["go","设计模式"],"title":"懒汉模式","uri":"https://xie-wenlin.github.io/posts/%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/"},{"categories":["go"],"content":"内存管理 在 go 语言中，内存管理是由 go 的运行时系统（runtime）自动完成的。程序员不需要手动分配或释放内存，也不需要担心内存泄漏问题。 go 的运行时系统使用了一种叫做垃圾回收（garbage collection）的技术来自动管理内存。它会监控内存使用情况，当某个对象不再被使用时，它会自动将其回收。这样，程序员就可以专注于编写业务逻辑，而不用担心内存管理问题。 不过，go 语言的垃圾回收并不是完美的。垃圾回收会产生性能开销，在高性能要求的场景下，垃圾回收可能会成为瓶颈。此外，垃圾回收也无法解决一些内存泄漏问题，例如循环引用。 Go 语言的内存管理模型涉及到两个重要的概念：堆和栈。堆是一个由程序员分配的内存区域，用于存储动态分配的变量，例如通过 new 关键字或者 make 函数创建的变量。栈是系统自动分配的内存区域，用于存储函数调用时的局部变量和函数参数。 ","date":"2022-12-10","objectID":"https://xie-wenlin.github.io/posts/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:0:0","tags":["go","内存管理"],"title":"内存管理","uri":"https://xie-wenlin.github.io/posts/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]